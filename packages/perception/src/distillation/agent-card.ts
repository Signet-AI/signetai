/**
 * Agent Card Generator
 *
 * Generates an A2A-compatible agent card from the cognitive profile,
 * and — critically — produces a training context markdown document that
 * can be injected into any agent's system prompt to make the agent
 * "know" the user.
 */

import { writeFileSync, mkdirSync } from "fs";
import { dirname } from "path";
import type { CognitiveProfile, AgentCard, AgentCardSkill } from "./types";

// ---------------------------------------------------------------------------
// Database interface
// ---------------------------------------------------------------------------

interface CardDb {
	prepare(sql: string): {
		all(...args: unknown[]): Record<string, unknown>[];
		get(...args: unknown[]): Record<string, unknown> | undefined;
	};
}

// ---------------------------------------------------------------------------
// Identity interface (optional on-chain identity)
// ---------------------------------------------------------------------------

interface OnChainIdentity {
	did?: string;
	signature?: string;
}

// ---------------------------------------------------------------------------
// Memory shape for card generation
// ---------------------------------------------------------------------------

interface MemorySummary {
	type: string;
	content: string;
	tags: string[];
	importance?: number;
	createdAt: string;
}

// ---------------------------------------------------------------------------
// Core Functions
// ---------------------------------------------------------------------------

/**
 * Generate an A2A-compatible agent card from the cognitive profile.
 */
export function generateAgentCard(
	profile: CognitiveProfile,
	memories: MemorySummary[],
	identity?: OnChainIdentity,
): AgentCard {
	// Build skills list from expertise + memory evidence
	const skills = buildSkillsList(profile, memories);

	// Detect agent name from environment or memories
	const name = detectAgentName(memories);

	const card: AgentCard = {
		name,
		description: generateDescription(profile),
		version: "1.0.0",
		generatedAt: new Date().toISOString(),

		skills,

		communicationStyle: {
			verbosity: profile.communication.verbosity,
			format: profile.communication.preferredFormats[0] || "markdown",
			tone: profile.communication.formality,
		},

		context: {
			timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
			peakHours: profile.workPatterns.peakHours,
			tools: {
				editor: profile.toolPreferences.editor,
				terminal: profile.toolPreferences.terminal,
				prefersCLI: profile.toolPreferences.prefersCLI,
			},
		},

		expertise: {
			primaryDomains: profile.expertise.primaryDomains,
			languages: profile.expertise.languages,
			frameworks: profile.expertise.frameworks,
		},
	};

	if (identity?.did) {
		card.identity = {
			did: identity.did,
			signature: identity.signature,
		};
	}

	return card;
}

/**
 * Export agent card to a JSON file.
 */
export function exportAgentCard(card: AgentCard, outputPath: string): void {
	mkdirSync(dirname(outputPath), { recursive: true });
	writeFileSync(outputPath, JSON.stringify(card, null, 2), "utf-8");
}

/**
 * THE KEY OUTPUT: Generate a training context markdown document
 * that can be injected into any agent's system prompt.
 *
 * This document should read naturally and be genuinely useful —
 * making any agent that reads it feel like it knows the user personally.
 */
export function generateTrainingContext(
	profile: CognitiveProfile,
	memories: MemorySummary[],
): string {
	const sections: string[] = [];

	// Header
	sections.push("# User Context — Personalization Guide");
	sections.push("");
	sections.push(
		"> This document was auto-generated by Signet from observed work patterns.",
	);
	sections.push(
		`> Last updated: ${profile.lastUpdated} | Confidence: ${Math.round(profile.confidenceScore * 100)}% | Observation: ${profile.observationDays} days`,
	);
	sections.push("");

	// --- Who They Are ---
	sections.push("## Who They Are");
	sections.push("");

	const domains = profile.expertise.primaryDomains;
	const languages = profile.expertise.languages;

	if (domains.length > 0 || languages.length > 0) {
		const domainStr = domains.length > 0 ? domains.join(", ") : "general software";
		const langStr = languages.length > 0 ? languages.join(", ") : "various";
		sections.push(
			`A developer working primarily in **${domainStr}**, using **${langStr}**.`,
		);
	} else {
		sections.push("A developer whose specific expertise is still being learned.");
	}

	if (profile.toolPreferences.editor !== "unknown") {
		sections.push(
			`Uses **${profile.toolPreferences.editor}** as their editor${profile.toolPreferences.terminal !== "unknown" ? ` and **${profile.toolPreferences.terminal}** as their terminal` : ""}.`,
		);
	}

	if (profile.toolPreferences.prefersCLI) {
		sections.push("Prefers CLI tools over GUIs when available.");
	}

	sections.push("");

	// --- How They Think ---
	sections.push("## How They Think");
	sections.push("");

	// Problem solving
	sections.push(`**Problem-solving approach:** ${profile.problemSolving.approach}`);
	if (profile.problemSolving.debuggingStyle !== "unknown") {
		sections.push(
			`**Debugging style:** ${profile.problemSolving.debuggingStyle}`,
		);
	}
	sections.push(
		`**Research depth:** ${profile.problemSolving.researchDepth} — ${describeResearchDepth(profile.problemSolving.researchDepth)}`,
	);
	if (profile.problemSolving.prefersTryFirst) {
		sections.push(
			"**Prefers to try things first** before planning extensively. Show working code over abstract explanations.",
		);
	} else {
		sections.push(
			"**Prefers to plan first** before trying. Give them the big picture and rationale before diving into code.",
		);
	}
	sections.push("");

	// Decision making
	sections.push(`**Decision speed:** ${profile.decisionMaking.speed}`);
	if (profile.decisionMaking.revisitsDecisions) {
		sections.push(
			"Tends to revisit decisions — don't be surprised if they change direction.",
		);
	} else {
		sections.push("Once decided, they commit. Respect their decisions.");
	}
	sections.push(
		`**Risk tolerance:** ${profile.decisionMaking.riskTolerance} — ${describeRiskTolerance(profile.decisionMaking.riskTolerance)}`,
	);
	sections.push("");

	// --- How to Communicate with Them ---
	sections.push("## How to Communicate with Them");
	sections.push("");

	sections.push(`**Verbosity:** ${profile.communication.verbosity}`);
	sections.push(describeVerbosity(profile.communication.verbosity));
	sections.push("");

	sections.push(`**Tone:** ${profile.communication.formality}`);
	sections.push(describeFormality(profile.communication.formality));
	sections.push("");

	if (profile.communication.preferredFormats.length > 0) {
		sections.push(
			`**Preferred formats:** ${profile.communication.preferredFormats.join(", ")}`,
		);
	}

	if (
		profile.communication.documentationHabits &&
		profile.communication.documentationHabits !== "unknown"
	) {
		sections.push(
			`**Documentation style:** ${profile.communication.documentationHabits}`,
		);
	}
	sections.push("");

	// --- When They Work ---
	sections.push("## When They Work");
	sections.push("");

	if (profile.workPatterns.peakHours.length > 0) {
		const peakRanges = formatHourRanges(profile.workPatterns.peakHours);
		sections.push(`**Peak hours:** ${peakRanges}`);
	}

	sections.push(
		`**Typical session:** ~${profile.workPatterns.averageSessionMinutes} minutes`,
	);
	sections.push(
		`**Context switching:** ${profile.workPatterns.contextSwitchFrequency}`,
	);
	sections.push(`**Breaks:** ${profile.workPatterns.breakFrequency}`);
	sections.push("");

	// --- What They Know ---
	sections.push("## What They Know");
	sections.push("");

	if (profile.expertise.primaryDomains.length > 0) {
		sections.push(
			`**Primary domains:** ${profile.expertise.primaryDomains.join(", ")}`,
		);
	}
	if (profile.expertise.languages.length > 0) {
		sections.push(
			`**Languages:** ${profile.expertise.languages.join(", ")}`,
		);
	}
	if (profile.expertise.frameworks.length > 0) {
		sections.push(
			`**Frameworks:** ${profile.expertise.frameworks.join(", ")}`,
		);
	}
	sections.push("");

	if (profile.expertise.weakAreas.length > 0) {
		sections.push(
			`**Areas where they might need more help:** ${profile.expertise.weakAreas.join(", ")}`,
		);
		sections.push("Be more explanatory and patient in these areas.");
		sections.push("");
	}

	// --- Key Skills with Evidence ---
	const skillMemories = memories.filter((m) => m.type === "skill");
	if (skillMemories.length > 0) {
		sections.push("## Demonstrated Skills");
		sections.push("");

		// Group by tags to get unique skills
		const skillCounts = new Map<string, number>();
		for (const mem of skillMemories) {
			for (const tag of mem.tags) {
				if (!isMetaTag(tag)) {
					skillCounts.set(tag, (skillCounts.get(tag) || 0) + 1);
				}
			}
		}

		// Sort by frequency
		const sortedSkills = Array.from(skillCounts.entries())
			.sort((a, b) => b[1] - a[1])
			.slice(0, 20);

		for (const [skill, count] of sortedSkills) {
			sections.push(`- **${skill}** (observed ${count}×)`);
		}
		sections.push("");
	}

	// --- Recent Decisions ---
	const decisionMemories = memories
		.filter((m) => m.type === "decision")
		.slice(0, 10);
	if (decisionMemories.length > 0) {
		sections.push("## Recent Decisions");
		sections.push("");
		for (const mem of decisionMemories) {
			sections.push(`- ${mem.content}`);
		}
		sections.push("");
	}

	// --- Tool Usage ---
	sections.push("## Tools & Automation");
	sections.push("");
	sections.push(
		`**Automation level:** ${profile.toolPreferences.automationLevel}`,
	);
	sections.push(describeAutomation(profile.toolPreferences.automationLevel));
	sections.push("");

	// --- Working with This User (the practical summary) ---
	sections.push("## Working with This User — Quick Reference");
	sections.push("");
	sections.push("**Do:**");
	sections.push(generateDos(profile));
	sections.push("");
	sections.push("**Don't:**");
	sections.push(generateDonts(profile));
	sections.push("");

	return sections.join("\n");
}

/**
 * Load memories from the database suitable for card/context generation.
 */
export function loadMemoriesForCard(db: CardDb): MemorySummary[] {
	try {
		const rows = db
			.prepare(
				`SELECT type, content, tags, importance, created_at
				 FROM memories
				 WHERE (is_deleted = 0 OR is_deleted IS NULL)
				   AND type IN ('skill', 'decision', 'fact', 'preference', 'procedural', 'pattern')
				 ORDER BY importance DESC, created_at DESC
				 LIMIT 500`,
			)
			.all() as Array<{
			type: string;
			content: string;
			tags: string;
			importance: number;
			created_at: string;
		}>;

		return rows.map((r) => ({
			type: r.type,
			content: r.content,
			tags: safeParseTags(r.tags),
			importance: r.importance,
			createdAt: r.created_at,
		}));
	} catch {
		return [];
	}
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

function buildSkillsList(
	profile: CognitiveProfile,
	memories: MemorySummary[],
): AgentCardSkill[] {
	const skillEvidence = new Map<string, number>();

	// Count skill evidence from memories
	for (const mem of memories) {
		if (mem.type === "skill") {
			for (const tag of mem.tags) {
				if (!isMetaTag(tag)) {
					skillEvidence.set(tag, (skillEvidence.get(tag) || 0) + 1);
				}
			}
		}
	}

	// Combine profile domains with evidence
	const skills: AgentCardSkill[] = [];

	for (const domain of profile.expertise.primaryDomains) {
		const slug = slugify(domain);
		skills.push({
			id: slug,
			name: domain,
			description: `Primary expertise domain with ${skillEvidence.get(domain.toLowerCase()) || 0} observations`,
			evidenceCount: skillEvidence.get(domain.toLowerCase()) || 0,
		});
	}

	// Add top skills from evidence that aren't already domains
	const domainSet = new Set(
		profile.expertise.primaryDomains.map((d) => d.toLowerCase()),
	);
	const sortedEvidence = Array.from(skillEvidence.entries())
		.filter(([k]) => !domainSet.has(k))
		.sort((a, b) => b[1] - a[1])
		.slice(0, 15);

	for (const [skill, count] of sortedEvidence) {
		skills.push({
			id: slugify(skill),
			name: skill,
			description: `Demonstrated through ${count} observations`,
			evidenceCount: count,
		});
	}

	return skills;
}

function detectAgentName(memories: MemorySummary[]): string {
	// Try to find a name from preference/fact memories
	for (const mem of memories) {
		if (mem.type === "preference" || mem.type === "fact") {
			const nameMatch = mem.content.match(
				/(?:name is|called|goes by|known as)\s+["']?(\w+)/i,
			);
			if (nameMatch) return `${nameMatch[1]}'s Agent`;
		}
	}

	return "User's Agent";
}

function generateDescription(profile: CognitiveProfile): string {
	const parts: string[] = [];

	if (profile.expertise.primaryDomains.length > 0) {
		parts.push(
			`Expert in ${profile.expertise.primaryDomains.slice(0, 3).join(", ")}`,
		);
	}

	if (profile.expertise.languages.length > 0) {
		parts.push(
			`works with ${profile.expertise.languages.slice(0, 3).join(", ")}`,
		);
	}

	parts.push(
		`${profile.problemSolving.approach} problem solver`,
	);
	parts.push(
		`${profile.communication.formality} communicator`,
	);

	return parts.join(". ") + ".";
}

function describeResearchDepth(depth: string): string {
	switch (depth) {
		case "surface":
			return "Looks for quick answers. Don't bury the lead.";
		case "moderate":
			return "Reads docs but doesn't go down rabbit holes. Give context when needed.";
		case "deep":
			return "Deep dives into topics. Appreciates thorough explanations and edge cases.";
		default:
			return "";
	}
}

function describeRiskTolerance(tolerance: string): string {
	switch (tolerance) {
		case "conservative":
			return "Suggest well-established approaches. Flag experimental options clearly.";
		case "moderate":
			return "Open to new tools/approaches if the value is clear.";
		case "bold":
			return "Loves trying new things. Feel free to suggest cutting-edge approaches.";
		default:
			return "";
	}
}

function describeVerbosity(v: string): string {
	switch (v) {
		case "terse":
			return "Keep responses short and to the point. Code > prose. Skip pleasantries.";
		case "moderate":
			return "Balance explanation with brevity. Include context when it adds value.";
		case "detailed":
			return "Appreciates thorough explanations. Include reasoning, alternatives, and caveats.";
		default:
			return "";
	}
}

function describeFormality(f: string): string {
	switch (f) {
		case "casual":
			return "Casual tone is fine. Use contractions, be conversational.";
		case "professional":
			return "Professional but not stuffy. Clear and respectful.";
		case "technical":
			return "Highly technical language is fine. No need to simplify jargon.";
		default:
			return "";
	}
}

function describeAutomation(level: string): string {
	switch (level) {
		case "manual":
			return "Prefers understanding each step. Explain what commands do before running them.";
		case "scripts":
			return "Uses scripts and automation when it saves time. Provide both manual and scripted options.";
		case "heavy-automation":
			return "Loves automation. Provide scripts, Makefiles, CI configs — automate everything.";
		default:
			return "";
	}
}

function generateDos(profile: CognitiveProfile): string {
	const dos: string[] = [];

	if (profile.communication.verbosity === "terse") {
		dos.push("- Get to the point quickly");
		dos.push("- Lead with code, follow with explanation if needed");
	} else if (profile.communication.verbosity === "detailed") {
		dos.push("- Explain your reasoning");
		dos.push("- Include context and alternatives");
	}

	if (profile.problemSolving.prefersTryFirst) {
		dos.push("- Provide runnable examples");
		dos.push("- Show working code first, explain later");
	} else {
		dos.push("- Explain the approach before showing code");
		dos.push("- Provide context for why this solution");
	}

	if (profile.toolPreferences.prefersCLI) {
		dos.push("- Give CLI commands over GUI instructions");
	}

	if (profile.decisionMaking.riskTolerance === "bold") {
		dos.push("- Suggest modern/cutting-edge solutions");
	} else if (profile.decisionMaking.riskTolerance === "conservative") {
		dos.push("- Prefer battle-tested solutions");
	}

	dos.push(
		`- Respect their ${profile.communication.formality} communication style`,
	);

	return dos.join("\n");
}

function generateDonts(profile: CognitiveProfile): string {
	const donts: string[] = [];

	if (profile.communication.verbosity === "terse") {
		donts.push("- Don't over-explain simple things");
		donts.push("- Don't add unnecessary preamble");
	}

	if (profile.communication.formality === "technical") {
		donts.push("- Don't dumb down technical concepts");
	}

	if (!profile.decisionMaking.revisitsDecisions) {
		donts.push("- Don't second-guess their architectural decisions");
	}

	if (profile.problemSolving.researchDepth === "surface") {
		donts.push("- Don't go into excessive detail unless asked");
	}

	if (profile.toolPreferences.prefersCLI) {
		donts.push("- Don't default to GUI solutions when CLI exists");
	}

	donts.push("- Don't assume expertise gaps in their known domains");

	return donts.join("\n");
}

function formatHourRanges(hours: number[]): string {
	if (hours.length === 0) return "unknown";

	const sorted = [...hours].sort((a, b) => a - b);
	const ranges: string[] = [];
	let start = sorted[0];
	let end = sorted[0];

	for (let i = 1; i < sorted.length; i++) {
		if (sorted[i] === end + 1) {
			end = sorted[i];
		} else {
			ranges.push(formatTimeRange(start, end));
			start = sorted[i];
			end = sorted[i];
		}
	}
	ranges.push(formatTimeRange(start, end));

	return ranges.join(", ");
}

function formatTimeRange(start: number, end: number): string {
	// M-10 FIX: Handle midnight wrapping correctly
	const fmt = (h: number) => {
		const wrapped = h % 24;
		if (wrapped === 0) return "12 AM";
		if (wrapped < 12) return `${wrapped} AM`;
		if (wrapped === 12) return "12 PM";
		return `${wrapped - 12} PM`;
	};

	if (start === end) return fmt(start);
	return `${fmt(start)}–${fmt(end + 1)}`;
}

function slugify(str: string): string {
	const result = str
		.toLowerCase()
		.replace(/[^a-z0-9]+/g, "-")
		.replace(/^-|-$/g, "");
	// L-12: Fallback for non-Latin input that produces empty slugs
	return result || "unknown-" + Math.random().toString(36).slice(2, 6);
}

function isMetaTag(tag: string): boolean {
	return [
		"skill",
		"technical",
		"domain",
		"process",
		"communication",
		"tool_mastery",
		"learning",
		"competent",
		"proficient",
		"expert",
	].includes(tag);
}

function safeParseTags(tags: string | null): string[] {
	if (!tags) return [];
	try {
		const parsed = JSON.parse(tags);
		return Array.isArray(parsed) ? parsed : [];
	} catch {
		return [];
	}
}
