#!/usr/bin/env node
/**
 * Signet CLI
 * Own your agent. Bring it anywhere.
 */

import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import { input, select, confirm, checkbox } from '@inquirer/prompts';
import { spawn } from 'child_process';
import { homedir } from 'os';
import { join, dirname } from 'path';
import { existsSync, mkdirSync, writeFileSync, readFileSync, copyFileSync, readdirSync } from 'fs';
import { fileURLToPath } from 'url';
import Database from 'better-sqlite3';

// Template directory location (relative to built CLI)
function getTemplatesDir() {
  // In development: packages/cli/templates
  // When installed: node_modules/@signet/cli/templates
  const devPath = join(__dirname, '..', 'templates');
  const distPath = join(__dirname, '..', '..', 'templates');
  
  if (existsSync(devPath)) return devPath;
  if (existsSync(distPath)) return distPath;
  
  // Fallback for bun build output
  return join(__dirname, 'templates');
}

function copyDirRecursive(src: string, dest: string) {
  mkdirSync(dest, { recursive: true });
  const entries = readdirSync(src, { withFileTypes: true });
  
  for (const entry of entries) {
    const srcPath = join(src, entry.name);
    const destPath = join(dest, entry.name);
    
    if (entry.isDirectory()) {
      copyDirRecursive(srcPath, destPath);
    } else {
      copyFileSync(srcPath, destPath);
    }
  }
}

// ============================================================================
// Harness Hook Configuration
// ============================================================================

async function configureHarnessHooks(harness: string, basePath: string) {
  const memoryScript = join(basePath, 'memory', 'scripts', 'memory.py');
  
  switch (harness) {
    case 'claude-code':
      await configureClaudeCodeHooks(basePath, memoryScript);
      break;
    case 'opencode':
      await configureOpenCodeHooks(basePath, memoryScript);
      break;
    case 'openclaw':
      await configureOpenClawHooks(basePath, memoryScript);
      break;
    // Other harnesses don't have hook systems yet
  }
}

async function configureClaudeCodeHooks(basePath: string, memoryScript: string) {
  const settingsPath = join(homedir(), '.claude', 'settings.json');
  
  // Create .claude directory if needed
  mkdirSync(join(homedir(), '.claude'), { recursive: true });
  
  // Load existing settings or create new
  let settings: Record<string, unknown> = {};
  if (existsSync(settingsPath)) {
    try {
      settings = JSON.parse(readFileSync(settingsPath, 'utf-8'));
    } catch {
      settings = {};
    }
  }
  
  // Add Signet hooks
  settings.hooks = {
    SessionStart: [{
      hooks: [{
        type: 'command',
        command: `${memoryScript} load --mode session-start --project "$(pwd)"`,
        timeout: 3000
      }]
    }],
    UserPromptSubmit: [{
      hooks: [{
        type: 'command',
        command: `${memoryScript} load --mode prompt --project "$(pwd)"`,
        timeout: 2000
      }]
    }],
    SessionEnd: [{
      hooks: [{
        type: 'command',
        command: `${memoryScript} save --mode auto`,
        timeout: 10000
      }]
    }]
  };
  
  writeFileSync(settingsPath, JSON.stringify(settings, null, 2));
  
  // Also generate CLAUDE.md from AGENTS.md
  const claudeMd = join(homedir(), '.claude', 'CLAUDE.md');
  const agentsMd = join(basePath, 'AGENTS.md');
  if (existsSync(agentsMd)) {
    const content = readFileSync(agentsMd, 'utf-8');
    const header = `# Auto-generated from ~/.agents/AGENTS.md
# Source: ${agentsMd}
# Generated: ${new Date().toISOString()}
# DO NOT EDIT - changes will be overwritten
# Edit ~/.agents/AGENTS.md instead

`;
    writeFileSync(claudeMd, header + content);
  }
}

async function configureOpenCodeHooks(basePath: string, memoryScript: string) {
  const opencodePath = join(homedir(), '.config', 'opencode');
  mkdirSync(opencodePath, { recursive: true });
  
  // Create memory plugin
  const pluginContent = `/**
 * Signet memory plugin for OpenCode
 * Auto-generated by signet setup
 */

import { tool } from '@opencode-ai/plugin'
import { spawn } from 'child_process'
import { homedir } from 'os'
import { join } from 'path'

const MEMORY_SCRIPT = '${memoryScript}'

async function runMemoryScript(args) {
  return new Promise((resolve, reject) => {
    const proc = spawn('python3', [MEMORY_SCRIPT, ...args], { timeout: 3000 })
    let stdout = '', stderr = ''
    proc.stdout.on('data', (d) => { stdout += d.toString() })
    proc.stderr.on('data', (d) => { stderr += d.toString() })
    proc.on('close', (code) => {
      if (code === 0) resolve(stdout.trim())
      else reject(new Error(stderr || \`exit code \${code}\`))
    })
    proc.on('error', reject)
  })
}

export async function MemoryPlugin({ directory }) {
  let memoryContext = ''
  try {
    memoryContext = await runMemoryScript(['load', '--mode', 'session-start', '--project', directory])
  } catch { memoryContext = '[memory active | /remember | /recall]' }

  return {
    "experimental.chat.system.transform": async (input, output) => {
      if (memoryContext) output.system.unshift(memoryContext)
    },
    "experimental.session.compacting": async (input, output) => {
      output.context.push('[memory active: /remember to save, /recall to query]')
    },
    tool: {
      remember: tool({
        description: "Save to persistent memory. Prefix with 'critical:' for important or '[tags]:' for tagged.",
        args: { content: tool.schema.string().describe("Content to remember") },
        async execute(args, context) {
          try {
            return await runMemoryScript(['save', '--mode', 'explicit', '--who', 'opencode', '--project', context.directory, '--content', args.content])
          } catch (e) { return \`error: \${e.message}\` }
        }
      }),
      recall: tool({
        description: "Query persistent memory.",
        args: { query: tool.schema.string().describe("Search query") },
        async execute(args) {
          try { return await runMemoryScript(['query', args.query]) || 'no memories found' }
          catch (e) { return \`error: \${e.message}\` }
        }
      })
    }
  }
}
`
  writeFileSync(join(opencodePath, 'memory.mjs'), pluginContent);
  
  // Generate AGENTS.md
  const agentsMd = join(basePath, 'AGENTS.md');
  if (existsSync(agentsMd)) {
    const content = readFileSync(agentsMd, 'utf-8');
    const header = `# Auto-generated from ~/.agents/AGENTS.md
# Source: ${agentsMd}
# Generated: ${new Date().toISOString()}
# DO NOT EDIT - changes will be overwritten
# Edit ~/.agents/AGENTS.md instead

`;
    writeFileSync(join(opencodePath, 'AGENTS.md'), header + content);
  }
}

async function configureOpenClawHooks(basePath: string, memoryScript: string) {
  const hookDir = join(basePath, 'hooks', 'agent-memory');
  mkdirSync(hookDir, { recursive: true });
  
  // Create HOOK.md
  const hookMd = `---
name: agent-memory
description: "Signet memory integration - hybrid search, auto-embedding, cross-harness persistence"
homepage: https://signetai.sh
metadata:
  {
    "openclaw": {
      "emoji": "ðŸ§ ",
      "events": ["command:new", "command:remember", "command:recall", "command:context"],
      "requires": { "bins": ["python3"] },
      "install": [{ "id": "workspace", "kind": "workspace", "label": "Workspace hook" }]
    }
  }
---

# Agent Memory Hook (Signet)

Unified memory system for all AI harnesses.
Uses hybrid search (vector + keyword) for semantic recall.

## Commands

- \`/context\` - Load memory context
- \`/remember <content>\` - Save a memory
- \`/recall <query>\` - Search memories
- \`/new\` - Auto-saves session context before reset
`
  writeFileSync(join(hookDir, 'HOOK.md'), hookMd);
  
  // Create handler.js
  const handlerJs = `/**
 * Signet Agent Memory Hook for OpenClaw
 * Auto-generated by signet setup
 */
import { spawn } from "node:child_process";
import path from "node:path";
import os from "node:os";
import fs from "node:fs/promises";

const MEMORY_SCRIPT = "${memoryScript}";

async function runMemoryScript(args) {
  return new Promise((resolve, reject) => {
    const proc = spawn("python3", [MEMORY_SCRIPT, ...args], { timeout: 5000 });
    let stdout = "", stderr = "";
    proc.stdout.on("data", (d) => { stdout += d.toString(); });
    proc.stderr.on("data", (d) => { stderr += d.toString(); });
    proc.on("close", (code) => {
      if (code === 0) resolve(stdout.trim());
      else reject(new Error(stderr || \`exit code \${code}\`));
    });
    proc.on("error", reject);
  });
}

const handler = async (event) => {
  try { await fs.access(MEMORY_SCRIPT); }
  catch { console.warn("[agent-memory] Script not found"); return; }

  if (event.type !== "command") return;
  const ctx = event.context || {};
  const args = ctx.args || "";

  switch (event.action) {
    case "remember":
      if (!args.trim()) {
        event.messages.push("ðŸ§  Usage: /remember <content>");
        return;
      }
      try {
        const result = await runMemoryScript(["save", "--mode", "explicit", "--who", "openclaw", "--project", ctx.cwd || os.homedir(), "--content", args.trim()]);
        event.messages.push(\`ðŸ§  \${result}\`);
      } catch (e) { event.messages.push(\`ðŸ§  Error: \${e.message}\`); }
      break;

    case "recall":
      if (!args.trim()) {
        event.messages.push("ðŸ§  Usage: /recall <query>");
        return;
      }
      try {
        const result = await runMemoryScript(["query", args.trim(), "--limit", "10"]);
        event.messages.push(result ? \`ðŸ§  Results:\\n\\n\${result}\` : "ðŸ§  No memories found.");
      } catch (e) { event.messages.push(\`ðŸ§  Error: \${e.message}\`); }
      break;

    case "context":
      try {
        const result = await runMemoryScript(["load", "--mode", "session-start", "--project", os.homedir()]);
        event.messages.push(result ? \`ðŸ§  **Context Loaded**\\n\\n\${result}\` : "ðŸ§  No context available.");
      } catch (e) { event.messages.push(\`ðŸ§  Error: \${e.message}\`); }
      break;

    case "new":
      // Session ending - could extract context here
      console.log("[agent-memory] Session ended");
      break;
  }
};

export default handler;
`
  writeFileSync(join(hookDir, 'handler.js'), handlerJs);
  
  // Create package.json for the hook
  const pkgJson = { name: "agent-memory", version: "1.0.0", type: "module" };
  writeFileSync(join(hookDir, 'package.json'), JSON.stringify(pkgJson, null, 2));
}

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const program = new Command();
const VERSION = '0.1.0';

// ============================================================================
// Helpers
// ============================================================================

function signetLogo() {
  return `
  ${chalk.hex('#C9A227')('â—ˆ')} ${chalk.bold('signet')} ${chalk.dim(`v${VERSION}`)}
  ${chalk.dim('own your agent. bring it anywhere.')}
`;
}

function detectExistingSetup(basePath: string) {
  const checks = {
    agentsDir: existsSync(basePath),
    agentsMd: existsSync(join(basePath, 'AGENTS.md')),
    memoryDb: existsSync(join(basePath, 'memory', 'memories.db')),
    configYaml: existsSync(join(basePath, 'config.yaml')),
  };
  return checks;
}

// ============================================================================
// signet setup - Interactive Setup Wizard
// ============================================================================

async function setupWizard(options: { path?: string }) {
  console.log(signetLogo());
  console.log();
  
  const basePath = options.path || join(homedir(), '.agents');
  const existing = detectExistingSetup(basePath);
  
  // Check for existing installation
  if (existing.agentsDir && existing.memoryDb) {
    console.log(chalk.green('  âœ“ Existing Signet installation detected'));
    console.log(chalk.dim(`    ${basePath}`));
    console.log();
    
    const action = await select({
      message: 'What would you like to do?',
      choices: [
        { value: 'dashboard', name: 'Launch dashboard' },
        { value: 'migrate', name: 'Import memories from another platform' },
        { value: 'reconfigure', name: 'Reconfigure settings' },
        { value: 'status', name: 'View status' },
        { value: 'exit', name: 'Exit' },
      ],
    });
    
    if (action === 'dashboard') {
      return launchDashboard({ path: basePath });
    } else if (action === 'migrate') {
      return migrateWizard(basePath);
    } else if (action === 'status') {
      return showStatus({ path: basePath });
    } else if (action === 'exit') {
      return;
    }
  }
  
  // Fresh installation
  console.log(chalk.bold('  Let\'s set up your agent identity.\n'));
  
  // Step 1: Name
  const agentName = await input({
    message: 'What should your agent be called?',
    default: 'My Agent',
  });
  
  // Step 2: Harnesses
  console.log();
  const harnesses = await checkbox({
    message: 'Which AI platforms do you use?',
    choices: [
      { value: 'claude-code', name: 'Claude Code (Anthropic CLI)' },
      { value: 'opencode', name: 'OpenCode' },
      { value: 'openclaw', name: 'OpenClaw' },
      { value: 'cursor', name: 'Cursor' },
      { value: 'windsurf', name: 'Windsurf' },
      { value: 'chatgpt', name: 'ChatGPT' },
      { value: 'gemini', name: 'Gemini' },
    ],
  });
  
  // Step 3: Embedding provider
  console.log();
  const embeddingProvider = await select({
    message: 'How should memories be embedded for search?',
    choices: [
      { value: 'ollama', name: 'Ollama (local, recommended)' },
      { value: 'openai', name: 'OpenAI API' },
      { value: 'none', name: 'Skip embeddings for now' },
    ],
  });
  
  // Step 4: Import existing conversations
  console.log();
  const wantImport = await confirm({
    message: 'Do you want to import existing conversations?',
    default: false,
  });
  
  // Execute setup
  console.log();
  const spinner = ora('Setting up Signet...').start();
  
  try {
    const templatesDir = getTemplatesDir();
    
    // Create directory structure
    mkdirSync(join(basePath, 'memory', 'scripts'), { recursive: true });
    mkdirSync(join(basePath, 'harnesses'), { recursive: true });
    
    // Copy memory scripts from templates
    spinner.text = 'Installing memory system...';
    const scriptsSource = join(templatesDir, 'memory', 'scripts');
    if (existsSync(scriptsSource)) {
      copyDirRecursive(scriptsSource, join(basePath, 'memory', 'scripts'));
    }
    
    // Copy utility scripts (generate-harness-configs.py etc)
    const utilScriptsSource = join(templatesDir, 'scripts');
    if (existsSync(utilScriptsSource)) {
      mkdirSync(join(basePath, 'scripts'), { recursive: true });
      copyDirRecursive(utilScriptsSource, join(basePath, 'scripts'));
    }
    
    // Create AGENTS.md from template or inline
    spinner.text = 'Creating agent identity...';
    const agentsTemplate = join(templatesDir, 'AGENTS.md.template');
    let agentsMd: string;
    if (existsSync(agentsTemplate)) {
      agentsMd = readFileSync(agentsTemplate, 'utf-8').replace(/\{\{AGENT_NAME\}\}/g, agentName);
    } else {
      agentsMd = `# ${agentName}

This is your agent identity file. Define your agent's personality, capabilities,
and behaviors here. This file is shared across all your AI tools.

## Personality

${agentName} is a helpful assistant.

## Instructions

- Be concise and direct
- Ask clarifying questions when needed
- Remember user preferences
`;
    }
    writeFileSync(join(basePath, 'AGENTS.md'), agentsMd);
    
    // Create config.yaml
    spinner.text = 'Writing configuration...';
    const config: Record<string, unknown> = {
      version: 1,
      agent: { name: agentName },
      harnesses: harnesses,
      memory: {
        database: 'memory/memories.db',
        vectors: 'memory/vectors.zvec',
      },
    };
    
    if (embeddingProvider !== 'none') {
      config.embedding = {
        provider: embeddingProvider,
        model: embeddingProvider === 'ollama' ? 'nomic-embed-text' : 'text-embedding-3-small',
        dimensions: embeddingProvider === 'ollama' ? 768 : 1536,
      };
    }
    
    writeFileSync(join(basePath, 'config.yaml'), formatYaml(config));
    
    // Create MEMORY.md from template or inline
    const memoryTemplate = join(templatesDir, 'MEMORY.md.template');
    let memoryMd: string;
    if (existsSync(memoryTemplate)) {
      memoryMd = readFileSync(memoryTemplate, 'utf-8').replace(/\{\{AGENT_NAME\}\}/g, agentName);
    } else {
      memoryMd = `# Memory

Current context and working memory for ${agentName}.
`;
    }
    writeFileSync(join(basePath, 'MEMORY.md'), memoryMd);
    
    // Initialize the database
    spinner.text = 'Initializing database...';
    const dbPath = join(basePath, 'memory', 'memories.db');
    const db = new Database(dbPath);
    
    db.exec(`
      CREATE TABLE IF NOT EXISTS schema_migrations (
        version INTEGER PRIMARY KEY,
        applied_at TEXT DEFAULT CURRENT_TIMESTAMP
      );
      
      CREATE TABLE IF NOT EXISTS memories (
        id TEXT PRIMARY KEY,
        content TEXT NOT NULL,
        type TEXT DEFAULT 'explicit',
        source TEXT DEFAULT 'manual',
        importance REAL DEFAULT 0.5,
        tags TEXT,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP,
        updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
        accessed_at TEXT,
        access_count INTEGER DEFAULT 0
      );
      
      CREATE TABLE IF NOT EXISTS conversations (
        id TEXT PRIMARY KEY,
        title TEXT,
        started_at TEXT DEFAULT CURRENT_TIMESTAMP,
        ended_at TEXT,
        message_count INTEGER DEFAULT 0,
        summary TEXT
      );
      
      CREATE VIRTUAL TABLE IF NOT EXISTS memories_fts USING fts5(
        content,
        tags,
        content='memories',
        content_rowid='rowid'
      );
      
      INSERT OR IGNORE INTO schema_migrations (version) VALUES (5);
    `);
    
    db.close();
    
    // Configure hooks for selected harnesses
    spinner.text = 'Configuring harness hooks...';
    const configuredHarnesses: string[] = [];
    
    for (const harness of harnesses) {
      try {
        await configureHarnessHooks(harness, basePath);
        configuredHarnesses.push(harness);
      } catch (err) {
        console.warn(`\n  âš  Could not configure ${harness}: ${(err as Error).message}`);
      }
    }
    
    spinner.succeed(chalk.green('Signet initialized!'));
    
    console.log();
    console.log(chalk.dim('  Files created:'));
    console.log(chalk.dim(`    ${basePath}/`));
    console.log(chalk.dim('    â”œâ”€â”€ AGENTS.md     agent identity'));
    console.log(chalk.dim('    â”œâ”€â”€ MEMORY.md     working memory'));
    console.log(chalk.dim('    â”œâ”€â”€ config.yaml   configuration'));
    console.log(chalk.dim('    â””â”€â”€ memory/       database & vectors'));
    
    if (configuredHarnesses.length > 0) {
      console.log();
      console.log(chalk.dim('  Hooks configured for:'));
      for (const h of configuredHarnesses) {
        console.log(chalk.dim(`    âœ“ ${h}`));
      }
    }
    console.log();
    
    if (wantImport) {
      await migrateWizard(basePath);
    }
    
    // Offer to launch dashboard
    const launchNow = await confirm({
      message: 'Launch the dashboard?',
      default: true,
    });
    
    if (launchNow) {
      await launchDashboard({ path: basePath });
    }
    
  } catch (err) {
    spinner.fail(chalk.red('Setup failed'));
    console.error(err);
    process.exit(1);
  }
}

// ============================================================================
// signet migrate - Import Wizard
// ============================================================================

async function migrateWizard(basePath: string) {
  console.log();
  console.log(chalk.bold('  Import existing conversations\n'));
  
  const source = await select({
    message: 'Where are you importing from?',
    choices: [
      { value: 'chatgpt', name: 'ChatGPT export (conversations.json)' },
      { value: 'claude', name: 'Claude export' },
      { value: 'gemini', name: 'Gemini / Google AI Studio' },
      { value: 'custom', name: 'Custom JSON format' },
    ],
  });
  
  const inputPath = await input({
    message: 'Path to export file:',
    validate: (v) => existsSync(v) || 'File not found',
  });
  
  const spinner = ora(`Importing from ${source}...`).start();
  
  try {
    // TODO: Implement actual migration logic via @signet/core
    // For now, placeholder
    await new Promise(r => setTimeout(r, 1500));
    
    spinner.succeed(chalk.green('Import complete!'));
    console.log(chalk.dim('  Imported X conversations with Y memories'));
  } catch (err) {
    spinner.fail(chalk.red('Import failed'));
    console.error(err);
  }
}

// ============================================================================
// signet dashboard - Launch Web UI
// ============================================================================

async function launchDashboard(options: { path?: string; port?: string }) {
  const basePath = options.path || join(homedir(), '.agents');
  const port = options.port || '3850';
  
  console.log(signetLogo());
  console.log(`  ${chalk.dim('Starting dashboard...')}`);
  console.log(`  ${chalk.cyan(`http://localhost:${port}`)}`);
  console.log();
  
  // Find the bundled dashboard build
  const dashboardLocations = [
    join(__dirname, '..', 'dashboard', 'build'),  // installed package
    join(__dirname, '..', '..', 'dashboard', 'build'),  // dev workspace
  ];
  
  let dashboardBuild: string | null = null;
  for (const loc of dashboardLocations) {
    if (existsSync(join(loc, 'index.js'))) {
      dashboardBuild = loc;
      break;
    }
  }
  
  if (dashboardBuild) {
    // Run the bundled SvelteKit server
    const proc = spawn('node', [join(dashboardBuild, 'index.js')], {
      stdio: 'inherit',
      env: { ...process.env, SIGNET_PATH: basePath, PORT: port, HOST: 'localhost' },
    });
    
    proc.on('error', (err) => {
      console.error(chalk.red('Failed to start dashboard:'), err.message);
      process.exit(1);
    });
  } else {
    // Development fallback - run vite dev
    const devPath = join(__dirname, '..', '..', 'dashboard');
    if (existsSync(join(devPath, 'package.json'))) {
      const proc = spawn('bun', ['run', 'dev', '--port', port], {
        cwd: devPath,
        stdio: 'inherit',
        env: { ...process.env, SIGNET_PATH: basePath },
      });
      
      proc.on('error', (err) => {
        console.error(chalk.red('Failed to start dashboard:'), err.message);
        process.exit(1);
      });
    } else {
      console.error(chalk.red('Dashboard not found. Try rebuilding: bun run build'));
      process.exit(1);
    }
  }
}

// ============================================================================
// signet status - Show Agent Status
// ============================================================================

async function showStatus(options: { path?: string }) {
  const basePath = options.path || join(homedir(), '.agents');
  const existing = detectExistingSetup(basePath);
  
  console.log(signetLogo());
  
  if (!existing.agentsDir) {
    console.log(chalk.yellow('  No Signet installation found.'));
    console.log(`  Run ${chalk.bold('signet setup')} to get started.`);
    return;
  }
  
  console.log(chalk.bold('  Status\n'));
  
  // Check files
  const checks = [
    { name: 'AGENTS.md', exists: existing.agentsMd },
    { name: 'config.yaml', exists: existing.configYaml },
    { name: 'memories.db', exists: existing.memoryDb },
  ];
  
  for (const check of checks) {
    const icon = check.exists ? chalk.green('âœ“') : chalk.red('âœ—');
    console.log(`  ${icon} ${check.name}`);
  }
  
  // Show memory count if db exists
  if (existing.memoryDb) {
    try {
      const db = new Database(join(basePath, 'memory', 'memories.db'), { readonly: true });
      
      const memoryCount = db.prepare('SELECT COUNT(*) as count FROM memories').get() as { count: number };
      const conversationCount = db.prepare('SELECT COUNT(*) as count FROM conversations').get() as { count: number } | undefined;
      
      console.log();
      console.log(chalk.dim(`  Memories: ${memoryCount.count}`));
      if (conversationCount) {
        console.log(chalk.dim(`  Conversations: ${conversationCount.count}`));
      }
      
      db.close();
    } catch {
      // Database might not have expected schema
    }
  }
  
  console.log();
  console.log(chalk.dim(`  Path: ${basePath}`));
  console.log();
}

// ============================================================================
// Utilities
// ============================================================================

function formatYaml(obj: Record<string, unknown>, indent = 0): string {
  const pad = '  '.repeat(indent);
  let result = '';
  
  for (const [key, value] of Object.entries(obj)) {
    if (Array.isArray(value)) {
      result += `${pad}${key}:\n`;
      for (const item of value) {
        result += `${pad}  - ${item}\n`;
      }
    } else if (typeof value === 'object' && value !== null) {
      result += `${pad}${key}:\n`;
      result += formatYaml(value as Record<string, unknown>, indent + 1);
    } else {
      result += `${pad}${key}: ${value}\n`;
    }
  }
  
  return result;
}

// ============================================================================
// CLI Definition
// ============================================================================

program
  .name('signet')
  .description('Own your agent. Bring it anywhere.')
  .version(VERSION);

program
  .command('setup')
  .description('Interactive setup wizard')
  .option('-p, --path <path>', 'Base path for agent files')
  .action(setupWizard);

program
  .command('dashboard')
  .alias('ui')
  .description('Launch the web dashboard')
  .option('-p, --path <path>', 'Base path for agent files')
  .option('--port <port>', 'Port to run on', '3850')
  .action(launchDashboard);

program
  .command('status')
  .description('Show agent status')
  .option('-p, --path <path>', 'Base path for agent files')
  .action(showStatus);

program
  .command('migrate')
  .description('Import from another platform')
  .argument('[source]', 'Source platform (chatgpt, claude, gemini)')
  .action(async (source) => {
    const basePath = join(homedir(), '.agents');
    if (source) {
      // Direct migration
      await migrateWizard(basePath);
    } else {
      // Interactive
      await migrateWizard(basePath);
    }
  });

// Default action when no command specified
program
  .action(async () => {
    const basePath = join(homedir(), '.agents');
    const existing = detectExistingSetup(basePath);
    
    if (existing.agentsDir && existing.memoryDb) {
      // Existing installation - show menu
      await setupWizard({});
    } else {
      // No installation - run setup
      await setupWizard({});
    }
  });

program.parse();
