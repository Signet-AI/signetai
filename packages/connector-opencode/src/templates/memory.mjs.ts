/**
 * Template for OpenCode memory.mjs plugin
 *
 * This plugin integrates Signet's memory system with OpenCode via
 * the Signet daemon API, providing /remember and /recall tools
 * and automatic context loading.
 */

export interface MemoryPluginOptions {
	daemonUrl?: string;
}

export function generateMemoryPlugin(
	options: MemoryPluginOptions = {},
): string {
	const daemonUrl = options.daemonUrl || "http://localhost:3850";

	return `/**
 * Signet memory plugin for OpenCode
 * Auto-generated by @signet/connector-opencode
 *
 * Provides:
 *   - /remember: Save to persistent memory
 *   - /recall: Query persistent memory
 *   - Automatic context loading on session start
 *
 * Requires Signet daemon running on ${daemonUrl}
 */
import { tool } from '@opencode-ai/plugin'

const DAEMON_URL = process.env.SIGNET_DAEMON_URL || '${daemonUrl}'

async function fetchDaemon(path, body) {
  try {
    const res = await fetch(\`\${DAEMON_URL}\${path}\`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(5000),
    })
    if (!res.ok) throw new Error(\`daemon \${res.status}\`)
    return await res.json()
  } catch (e) {
    return null
  }
}

export async function MemoryPlugin({ directory }) {
  let memoryContext = ''
  try {
    const data = await fetchDaemon('/api/hooks/session-start', {
      harness: 'opencode',
      project: directory,
    })
    memoryContext = data?.inject || '[memory active | /remember | /recall]'
  } catch {
    memoryContext = '[memory active | /remember | /recall]'
  }

  return {
    "experimental.chat.system.transform": async (input, output) => {
      if (memoryContext) output.system.unshift(memoryContext)
    },
    tool: {
      remember: tool({
        description: "Save to persistent memory",
        args: { content: tool.schema.string().describe("Content to remember") },
        async execute(args, context) {
          const data = await fetchDaemon('/api/hooks/remember', {
            harness: 'opencode',
            who: 'opencode',
            project: context.directory,
            content: args.content,
          })
          if (data?.saved) return \`saved: \${args.content.slice(0, 50)}...\`
          return 'error: could not save memory'
        }
      }),
      recall: tool({
        description: "Query persistent memory",
        args: { query: tool.schema.string().describe("Search query") },
        async execute(args, context) {
          const data = await fetchDaemon('/api/hooks/recall', {
            harness: 'opencode',
            query: args.query,
            project: context.directory,
          })
          if (!data?.results?.length) return 'no memories found'
          return data.results.map(r => \`- \${r.content}\`).join('\\n')
        }
      })
    }
  }
}
`;
}
