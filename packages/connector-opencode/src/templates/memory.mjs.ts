/**
 * Template for OpenCode memory.mjs plugin
 *
 * This plugin integrates Signet's memory system with OpenCode,
 * providing /remember and /recall tools and automatic context loading.
 */

export interface MemoryPluginOptions {
	/** Path to the memory.py script */
	memoryScript: string;
}

/**
 * Generate the memory.mjs plugin content for OpenCode
 */
export function generateMemoryPlugin(options: MemoryPluginOptions): string {
	const { memoryScript } = options;

	return `/**
 * Signet memory plugin for OpenCode
 * Auto-generated by @signet/connector-opencode
 *
 * Provides:
 *   - /remember: Save to persistent memory
 *   - /recall: Query persistent memory
 *   - Automatic context loading on session start
 *
 * Note: OpenCode does not yet support SessionEnd hooks.
 * Memories are saved explicitly via /remember or auto-saved
 * by the Signet daemon if running.
 */
import { tool } from '@opencode-ai/plugin'
import { spawn } from 'child_process'

const MEMORY_SCRIPT = '${memoryScript}'

async function runMemoryScript(args) {
  return new Promise((resolve, reject) => {
    const proc = spawn('python3', [MEMORY_SCRIPT, ...args], { timeout: 3000 })
    let stdout = '', stderr = ''
    proc.stdout.on('data', (d) => { stdout += d.toString() })
    proc.stderr.on('data', (d) => { stderr += d.toString() })
    proc.on('close', (code) => {
      if (code === 0) resolve(stdout.trim())
      else reject(new Error(stderr || \`exit code \${code}\`))
    })
    proc.on('error', reject)
  })
}

export async function MemoryPlugin({ directory }) {
  let memoryContext = ''
  try {
    memoryContext = await runMemoryScript(['load', '--mode', 'session-start', '--project', directory])
  } catch { memoryContext = '[memory active | /remember | /recall]' }

  return {
    "experimental.chat.system.transform": async (input, output) => {
      if (memoryContext) output.system.unshift(memoryContext)
    },
    tool: {
      remember: tool({
        description: "Save to persistent memory",
        args: { content: tool.schema.string().describe("Content to remember") },
        async execute(args, context) {
          try {
            return await runMemoryScript(['save', '--mode', 'explicit', '--who', 'opencode', '--project', context.directory, '--content', args.content])
          } catch (e) { return \`error: \${e.message}\` }
        }
      }),
      recall: tool({
        description: "Query persistent memory",
        args: { query: tool.schema.string().describe("Search query") },
        async execute(args) {
          try { return await runMemoryScript(['query', args.query]) || 'no memories found' }
          catch (e) { return \`error: \${e.message}\` }
        }
      })
    }
  }
}
`;
}
