/**
 * DID setup integration — auto-generates keypair and DID during signet setup.
 *
 * Called during initial setup or via `signet did init` to bootstrap the
 * agent's cryptographic identity.
 */

import { existsSync, readFileSync, writeFileSync } from "fs";
import { join } from "path";
import { parse, stringify } from "yaml";
import {
	generateSigningKeypair,
	hasSigningKeypair,
	getPublicKeyBytes,
	resolveAgentsDir,
} from "./crypto";
import { publicKeyToDid, generateDidDocument, formatDidShort } from "./did";

/**
 * Use the shared, validated resolveAgentsDir() from crypto.ts.
 * This ensures SIGNET_PATH is validated identically in both modules —
 * no more raw `process.env.SIGNET_PATH` access that bypasses security checks.
 */
const AGENTS_DIR = resolveAgentsDir();

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

export interface DidSetupResult {
	/** Whether a new keypair was generated (false if one already existed) */
	keypairGenerated: boolean;
	/** The agent's DID (did:key:z6Mk...) */
	did: string;
	/** Shortened DID for display */
	didShort: string;
	/** Whether agent.yaml was updated with the DID */
	yamlUpdated: boolean;
	/** Path to the DID Document file */
	didDocumentPath: string;
}

// ---------------------------------------------------------------------------
// Public API
// ---------------------------------------------------------------------------

/**
 * Initialize the agent's DID identity.
 *
 * 1. Generates Ed25519 keypair if none exists
 * 2. Derives DID from public key
 * 3. Updates agent.yaml with the DID
 * 4. Writes DID Document to ~/.agents/did.json
 *
 * Safe to call multiple times — skips steps already completed.
 */
export async function initializeAgentDid(): Promise<DidSetupResult> {
	let keypairGenerated = false;

	// Step 1: Ensure keypair exists
	if (!hasSigningKeypair()) {
		await generateSigningKeypair();
		keypairGenerated = true;
	}

	// Step 2: Derive DID from public key
	const publicKey = await getPublicKeyBytes();
	const did = publicKeyToDid(publicKey);
	const didShort = formatDidShort(did);

	// Step 3: Update agent.yaml
	const yamlPath = join(AGENTS_DIR, "agent.yaml");
	let yamlUpdated = false;

	if (existsSync(yamlPath)) {
		try {
			const raw = readFileSync(yamlPath, "utf-8");
			const config = parse(raw) as Record<string, unknown>;

			if (config.did && config.did !== did) {
				// DID mismatch — existing DID doesn't match derived key.
				// This could mean the keypair was rotated without updating config,
				// or the file was tampered with.
				throw new Error(
					`DID mismatch: agent.yaml has ${config.did} but current keypair ` +
					`derives ${did}. Delete the old DID or rotate keys explicitly.`,
				);
			}

			if (!config.did) {
				// Append DID config to existing file instead of rewriting.
				// This preserves user comments in agent.yaml (stringify
				// would destroy them).
				const existingContent = readFileSync(yamlPath, "utf-8");
				let appendBlock = `\n# DID identity (auto-generated by signet did init)\ndid: "${did}"\n`;
				if (!config.signing) {
					appendBlock += "signing:\n  autoSign: true\n";
				}
				writeFileSync(yamlPath, existingContent + appendBlock);
				yamlUpdated = true;
			}
		} catch (err) {
			console.warn(
				"[did-setup] Failed to update agent.yaml:",
				err instanceof Error ? err.message : String(err),
			);
		}
	}

	// Step 4: Write DID Document
	const didDocument = generateDidDocument(did, publicKey);
	const didDocPath = join(AGENTS_DIR, "did.json");

	try {
		// DID documents are public data but written with restricted perms
		// for consistency with the rest of the .agents/ directory.
		writeFileSync(didDocPath, JSON.stringify(didDocument, null, 2), { mode: 0o644 });
	} catch (err) {
		console.warn(
			"[did-setup] Failed to write did.json:",
			err instanceof Error ? err.message : String(err),
		);
	}

	return {
		keypairGenerated,
		did,
		didShort,
		yamlUpdated,
		didDocumentPath: didDocPath,
	};
}

/**
 * Get the agent's current DID from agent.yaml.
 * Returns null if no DID is configured.
 */
export function getConfiguredDid(): string | null {
	const yamlPath = join(AGENTS_DIR, "agent.yaml");
	if (!existsSync(yamlPath)) return null;

	try {
		const raw = readFileSync(yamlPath, "utf-8");
		const config = parse(raw) as Record<string, unknown>;
		return typeof config.did === "string" ? config.did : null;
	} catch {
		return null;
	}
}

/**
 * Check if the agent has a DID configured.
 */
export function hasConfiguredDid(): boolean {
	return getConfiguredDid() !== null;
}

/**
 * Check if auto-signing is enabled in agent.yaml.
 * Cached for 60 seconds to avoid reading the file on every memory creation.
 * The cache is invalidated by initializeAgentDid() (key rotation).
 */
let _autoSignCache: { value: boolean; expiresAt: number } | null = null;
export function isAutoSignEnabled(): boolean {
	const now = Date.now();
	if (_autoSignCache && _autoSignCache.expiresAt > now) {
		return _autoSignCache.value;
	}

	const yamlPath = join(AGENTS_DIR, "agent.yaml");
	if (!existsSync(yamlPath)) {
		_autoSignCache = { value: false, expiresAt: now + 60_000 };
		return false;
	}

	try {
		const raw = readFileSync(yamlPath, "utf-8");
		const config = parse(raw) as Record<string, unknown>;
		const signing = config.signing as Record<string, unknown> | undefined;
		const result = signing?.autoSign === true;
		_autoSignCache = { value: result, expiresAt: now + 60_000 };
		return result;
	} catch {
		_autoSignCache = { value: false, expiresAt: now + 60_000 };
		return false;
	}
}

/**
 * Invalidate the auto-sign cache. Called after key rotation/DID changes.
 */
export function invalidateAutoSignCache(): void {
	_autoSignCache = null;
}
